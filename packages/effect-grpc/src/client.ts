// packages/effect-grpc/src/client.ts
import type * as http2 from "node:http2";
import { Context, Effect, Layer, Scope, Types } from "effect";

import type { BinaryReadOptions, BinaryWriteOptions } from "@bufbuild/protobuf";
import type { GenService, GenServiceMethods } from "@bufbuild/protobuf/codegenv2";
import { type ContextValues } from "@connectrpc/connect";
import type { Http2SessionOptions } from "@connectrpc/connect-node";
import type { Compression } from "@connectrpc/connect/protocol";

import * as internal from "./client.internal.js";
import type * as ProtoRuntime from "./protoRuntime.js";

export type GrpcClientRuntimeTypeId = typeof internal.grpcClientRuntimeTypeId;

/**
 * Core interface for gRPC client operations in the Effect ecosystem.
 *
 * The GrpcClient provides underlying executor implementation for gRPC service methods,
 * allowing type-safe invocation of remote procedures through Effect. This entity is
 * used in Codegen and Configurations to generate type-safe client code.
 *
 * @example
 * ```typescript
 * // This code is usually generated by protoc-gen-effect
 * // See packages/effect-grpc/src-template/hello_world_api_effect.ts
 * const prog = Effect.gen(function* () {
 *   const grpcService = yield* EffectGrpcClient.GrpcClient;
 *   const executor = grpcService.makeExecutor(HelloWorldAPI, ["getGreeting"]);
 *
 *   return {
 *     getGreeting(req, meta) {
 *       return executor.getGreeting(req, transformMeta(meta));
 *     }
 *   };
 * });
 * ```
 *
 * @category Client
 * @since 0.2.0
 */
export interface GrpcClientRuntime {
  readonly Type: GrpcClientRuntimeTypeId;

  makeExecutor<Shape extends GenServiceMethods>(
    serviceDefinition: GenService<Shape>,
    methodNames: ReadonlyArray<keyof GenService<Shape>["method"]>,
    config: GrpcClientConfig<any>,
  ): Effect.Effect<ProtoRuntime.ClientExecutor<Shape>, never, Scope.Scope>;
}
/**
 * Context tag for accessing the GrpcClient service.
 *
 * Use this tag to access the GrpcClient implementation in your Effect programs.
 * The tag provides dependency injection for the gRPC client functionality.
 *
 * @example
 * ```typescript
 * import { Effect } from "effect";
 * import { GrpcClient, liveGrpcClientLayer } from "@dr_nikson/effect-grpc";
 *
 * const program = Effect.gen(function* () {
 *   const client = yield* GrpcClient;
 *   return client;
 * }).pipe(
 *   Effect.provide(liveGrpcClientLayer())
 * );
 * ```
 *
 * @category Client
 * @since 0.2.0
 */
export const GrpcClientRuntime: Context.Tag<GrpcClientRuntime, GrpcClientRuntime> =
  internal.grpcClientRuntimeTag;

/**
 * Creates a live layer implementation for the GrpcClient service.
 *
 * This layer provides the default implementation of the GrpcClient interface,
 * enabling gRPC client functionality in your Effect applications.
 *
 * @example
 * ```typescript
 * import { Effect } from "effect";
 * import { GrpcClient, liveGrpcClientLayer } from "@dr_nikson/effect-grpc";
 *
 * const program = Effect.gen(function* () {
 *   const client = yield* GrpcClient;
 *   return client.makeExecutor(serviceDefinition, ["methodName"]);
 * }).pipe(
 *   Effect.provide(liveGrpcClientLayer())
 * );
 * ```
 *
 * @category Client
 * @since 0.2.0
 */
export const liveGrpcClientRuntimeLayer: {
  (): Layer.Layer<GrpcClientRuntime>;
} = internal.liveGrpcClientRuntime;

/**
 * TODO: mention in the example services here is like "com.example.v1.GetGreetingResponse"
 * @see [GrpcTransportOptions]{@link https://github.com/connectrpc/connect-es/blob/78b40abd3ecd2f4fa2dda6382e371be8e9de3f6d/packages/connect-node/src/grpc-transport.ts#L34}
 *
 */
export interface GrpcClientConfig<in Service extends string> {
  readonly _Service: Types.Contravariant<Service>;

  /**
   * Base URI for all requests.
   *
   * Requests will be made to <baseUrl>/<package>.<service>/method
   *
   * Example: `baseUrl: "https://example.com/my-api"`
   *
   * This will make a `POST /my-api/my_package.MyService/Foo` to
   * `example.com`
   */
  readonly baseUrl: URL;

  /**
   * Options for the binary wire format.
   */
  readonly binaryOptions?: Partial<BinaryReadOptions & BinaryWriteOptions>;

  /**
   * Compression algorithms available to a client. Clients ask servers to
   * compress responses using any of the registered algorithms. The first
   * registered algorithm is the most preferred.
   *
   * It is safe to use this option liberally: servers will ignore any
   * compression algorithms they don't support. To compress requests, pair this
   * option with `sendCompression`.
   *
   * If this option is not provided, the compression algorithms "gzip" and "br"
   * (Brotli) are accepted. To opt out of response compression, pass an
   * empty array.
   */
  readonly acceptCompression?: Compression[];

  /**
   * Configures the client to use the specified algorithm to compress request
   * messages.
   *
   * Because some servers don't support compression, clients default to sending
   * uncompressed requests.
   */
  readonly sendCompression?: Compression;

  /**
   * Sets a minimum size threshold for compression: Messages that are smaller
   * than the configured minimum are sent uncompressed.
   *
   * The default value is 1 kibibyte, because the CPU cost of compressing very
   * small messages usually isn't worth the small reduction in network I/O.
   */
  readonly compressMinBytes?: number;

  /**
   * The timeout in milliseconds to apply to all requests.
   *
   * This can be overridden on a per-request basis by passing a timeoutMs.
   */
  readonly defaultTimeoutMs?: number;

  /**
   * Options for HTTP/2 session keepalive behavior.
   *
   * Configure PING frame intervals and timeouts to maintain long-lived
   * HTTP/2 connections. This is important for detecting dead connections
   * and preventing resource exhaustion.
   *
   * @example
   * ```typescript
   * const config = GrpcClientConfig({
   *   baseUrl: new URL("http://localhost:8080"),
   *   pingOptions: {
   *     pingIntervalMs: 30000,  // Send PING every 30 seconds
   *     pingTimeoutMs: 15000,   // Timeout after 15 seconds
   *     pingIdleConnection: true,
   *     idleConnectionTimeoutMs: 900000, // Close idle connections after 15 minutes
   *   }
   * });
   * ```
   *
   * @see [Http2SessionOptions]{@link https://connectrpc.com/docs/node/using-clients}
   */
  readonly pingOptions?: Http2SessionOptions;

  /**
   * Advanced options for the underlying Node.js HTTP/2 client session.
   *
   * These options are passed directly to Node.js's `http2.connect()`.
   * Use this to configure TLS settings, ALPN protocols, and other
   * low-level HTTP/2 behavior.
   *
   * @see [Node.js HTTP/2 ClientSessionOptions]{@link https://nodejs.org/api/http2.html#http2connectauthority-options-listener}
   */
  readonly http2SessionOptions?: http2.ClientSessionOptions | http2.SecureClientSessionOptions;
}
export const GrpcClientConfig: {
  <Service extends string>(
    opts: Omit<GrpcClientConfig<Service>, "_Service">,
  ): GrpcClientConfig<Service>;

  makeTag<Service extends string>(
    service: Service,
  ): Context.Tag<GrpcClientConfig<Service>, GrpcClientConfig<Service>>;
} = Object.assign(internal.makeGrpcClientConfig.bind(null), {
  makeTag: internal.makeGrpcClientConfigTag,
});

/**
 * Metadata that can be attached to gRPC requests.
 *
 * This type defines the structure for additional information that can be sent
 * with gRPC calls, including Connect-RPC context values and HTTP headers.
 *
 * @example
 * ```typescript
 * import { RequestMeta } from "@dr_nikson/effect-grpc";
 *
 * const meta: RequestMeta = {
 *   headers: new Headers({ "Authorization": "Bearer token" }),
 *   contextValues: { timeout: 5000 }
 * };
 *
 * // Used in generated client code
 * const result = yield* client.getGreeting(request, meta);
 * ```
 *
 * @category Client
 * @since 0.2.0
 */
export type RequestMeta = {
  readonly contextValues?: ContextValues;
  readonly headers?: Headers;
};
